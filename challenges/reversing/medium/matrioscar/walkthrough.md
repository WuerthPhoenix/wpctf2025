# Matrioscar

## The Challenge

During a penetration test performed by our Red Team, a member stumbled upon a
remote service running on an internal host. They tried connecting to it, and they
found a service that advertises a “OSCO Protocol, Admin Access ONLY, All rights
reserved.” Connecting to the remote service shows a banner and prompt — but any
plain-text input immediately crashes the process. It looks like the program
expects a tightly-formatted, encoded/encrypted payload instead of normal
commands. Fortunately another insecure service allowed your team to download the
binary for offline analysis.

Your task? Reverse the binary’s input handling, craft a valid payload, and make
the service accept it to reveal the secret shell.

## Description

The challenge provides a binary that opens a prompt asking for input. However,
any normal input causes the program to exit. This probably indicates that the
program expects a specific format for the input, encoded and/or encrypted.

## How to solve

There are many ways to approach this challenge. One straightforward method is to
use `strings`. Doing this reveals strings like
`Could not load PyInstaller's embedded PKG archive from the executable`,
indicating that the binary is a PyInstaller package. We can use tools such as
this [PyInstaller extractor](https://github.com/extremecoders-re/pyinstxtractor)
to extract the contents of the binary.

Other ways are to use `binwalk` to analyze the binary structure, and then
scripting to extract the embedded files.

After extraction, we can look for the most relevant files. Indeed, we can find a
`main.pyc` file, which is the compiled Python bytecode for the main program.

Using decompilation tools such as [PyLingual](https://pylingual.io), we can
decompile the `main.pyc` file to get something like this:

```python
# Decompiled with PyLingual (https://pylingual.io)
# Internal filename: main.py
# Bytecode version: 3.13.0rc3 (3571)
# Source timestamp: 1970-01-01 00:00:00 UTC (0)

from typing import Callable
from pyo3_crypto.pyo3_crypto import clever_turing, diligent_tesla, elated_liskov, fervent_ramanujan, flamboyant_shannon, frosty_shannon, gifted_brahmagupta, interesting_agnesi, jovial_babbage, meticulous_einstein, pensive_engelbart, tender_dijkstra, thirsty_leakey, youthful_dhawan, zealous_visvesvaraya
FUNCTIONS: list[Callable[[bytes], bytes]] = [fervent_ramanujan, diligent_tesla, elated_liskov, clever_turing, thirsty_leakey, interesting_agnesi, gifted_brahmagupta, frosty_shannon, pensive_engelbart, youthful_dhawan, fervent_ramanujan, zealous_visvesvaraya, flamboyant_shannon]

def main() -> None:
    print("OSCO Protocol, Admin Access ONLY, All rights reserved.")
    user_input = input('~> ').encode()
    ord = meticulous_einstein(len(FUNCTIONS))
    user_input = fervent_ramanujan(user_input)
    user_input = diligent_tesla(user_input)
    user_input = elated_liskov(user_input)
    user_input = clever_turing(user_input)
    user_input = thirsty_leakey(user_input)
    user_input = interesting_agnesi(user_input)
    user_input = gifted_brahmagupta(user_input)
    for idx in ord:
        user_input = FUNCTIONS[idx](user_input)
    user_input = frosty_shannon(user_input)
    user_input = pensive_engelbart(user_input)
    user_input = youthful_dhawan(user_input)
    user_input = fervent_ramanujan(user_input)
    user_input = zealous_visvesvaraya(user_input)
    user_input = flamboyant_shannon(user_input)
    user_input = tender_dijkstra(user_input)
    print(jovial_babbage(user_input), end='')
if __name__ == '__main__':
    try:
        main()
    except BaseException:
        pass
```

From the decompiled code, we can see that the program imports several functions
from a module named `pyo3_crypto`. The `main` function prints a banner, takes
user input, encodes it to bytes, and then processes it through the imported
functions in a specific order. The order of function calls is determined by the
`ord` variable, which is generated by calling `meticulous_einstein` with the
length of the `FUNCTIONS` list.

Inside the extracted files, we can find the `pyo3_crypto` module, which is a `.so`
shared library file. This file contains the implementations of the functions
and we can use tools like `Ghidra` to reverse-engineer the compiled code.

Using the searching capabilities of `Ghidra``, we can locate the functions
defined in the`pyo3_crypto` module, since the shared library is not stripped.
By analyzing the functions, we can understand their purpose and how they
manipulate the input data.

To exploit we simply need to reverse the transformations applied to the input in
the `main` function, and generate a valid payload that will be accepted by the
remote service. Furthermore, the last function, once reversed, reveals to be
a command execution function, so basically the challenge is to create a payload
that once processed, will extract the flag form `/flag.txt`.
